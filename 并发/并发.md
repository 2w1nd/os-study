## 并发介绍
&ensp;&ensp;每个线程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据<br/>
&ensp;&ensp;每个线程都有一个程序计数器，用于记录程序从哪里获取指令。<br/>
&ensp;&ensp;对于进程，我们将状态保存到进程控制块（PCB），现在，我们需要一个或多个线程控制块，保存每个线程的状态，与进程相比，线程之间上下文切换有一点主要区别：地址空间保持不变。<br/>
&ensp;&ensp;
### 1.线程创建
&ensp;&ensp;程序见t0.c，执行后会发现结果是不确定的，线程的创建有点像进行函数调用。然而，并不是首先执行函数然后返回给调用者，而是为被调用的例程创建一个新的执行线程，它可以独立于调用者运行，可以在创建者返回之前运行，但也许会晚很多。
### 2.锁
&ensp;&ensp;并发的基本问题：希望原子式执行一系列指令，但由于单处理器的中断，这很难做到。<br/>
&ensp;&ensp;锁就是一个变量。这个锁变量保存了锁在某一时刻的状态，它要么是可用的，（available）表示没有线程持有锁，要么被占用的（acquired）表示有一个线程持有锁。<br/>
&ensp;&ensp;lock()和unlock()函数，调用lock（）尝试获取锁，如果没有其他线程持有锁，该线程会获得锁，进入临界区。一旦调用unlock（），锁就变成可用的了，如果没有其他等待线程。<br/>
&ensp;&ensp;锁提供了最小程度的调度控制。
#### Pthread锁
&ensp;&ensp;POSIX将锁称为互斥量（mutex），用来提供线程之间的互斥。
```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER
Pthread_mutex_loack(&lock);
balance = balance + 1;
Pthread_mutex_unlock(&lock)
```
&ensp;&ensp;不同于任何临界区都使用同一个大锁，通常大家会用不同的锁保护不同的数据和结构，从而允许更多的线程进入临界区.
#### 评价锁
&ensp;&ensp;如何评价锁的性能？一，锁是否能完成它的基本任务，即提供互斥。二，公平性（不会产生饿死或死锁）。三，性能
#### 控制中断
&ensp;&ensp;最开始的互斥解决方案就是在临界区关闭中断，优点是简单，容易理解，缺点就是允许所有调用线程执行特权操作（打开关闭中断），即信任这种机制不会被滥用。




