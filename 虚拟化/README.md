## 虚拟化
### 1. 抽象：进程
&ensp;&ensp;进程的非正式定义非常简单：进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。<br/>
&ensp;&ensp;进程API有`创建，销毁，等待，查看状态`
#### 进程创建
&ensp;&ensp;操作系统会将代码和所有静态数据加载到内存中，加载到进程的地址空间中。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节。
![](image/2021-10-13-14-06-01.png#pic_center)<br/>
&ensp;&ensp;操作系统将代码加载到内存中后，必要的为栈，堆分配一些内存，还会执行一些初始化任务，特别是IO相关的任务
#### 进程状态
&ensp;&ensp;进程有三种基本状态：`运行，就绪，阻塞`
![](image/2021-10-13-14-10-39.png)<br/>
### 2. 机制：受限直接执行
&ensp;&ensp;为了让许多任务看起来是在同时运行，操作系统以一种`时分共享CPU`进行操作：运行一个进程一段时间，然后运行另一个进程，如此轮换。然而，在构建虚拟化机制时存在一些挑战：`性能`和`控制权`
#### 受限制直接执行
![](image/2021-10-13-14-18-56.png)<br/>
&ensp;&ensp;上图是在无限制情况直接运行协议，这里有两个问题：如何确保程序不做其他事，从而高效的执行（控制权）？如何让其在需要的时候切换到另一个进程？<br/>
#### 问题1 ：受限的操作
&ensp;&ensp;一个进程必须能够执行IO和一些受限制的操作，但又不能完全控制操作系统
> &ensp;&ensp;在用户模式下，应用程序不能完全访问硬件资源。在内核模式下，操作系统可以访问机器的全部资源，还提供了陷入（trap）内核和陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表在内存种的位置<br>

&ensp;&ensp;系统调用允许内核向用户程序暴露某些关键功能，如访问文件系统，创建和销毁进程与其他进程通信等。<br/>
&ensp;&ensp;要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。
&ensp;&ensp;内核通过启动时设置陷阱表来实现控制在陷阱上执行的代码
![](image/2021-10-13-14-41-40.png)
#### 问题2：在进程之间切换
##### 协作方式：等待系统调用
&ensp;&ensp;在这种风格下，操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。
在协作调度系统中，OS通过等待系统调用，或某种非法操作发生，从而重新获得CPU的控制权。
##### 非协作方式：操作系统进行控制
&ensp;&ensp;在协作方式中，当进程陷入无限循环时，唯一的办法就是使用古老的解决方案来解决计算机系统中的所有问题——重新启动计算机。
&ensp;&ensp;在进程不协作的情况下，操作系统通过`时钟中断`获得CPU的控制权。<br/>
&ensp;&ensp;时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的`中断处理程序`会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：`停止当前进程`，并启动另一个进程。

